console.log("Record 1");

setTimeout(() => {
  console.log("Record 2");
  Promise.resolve().then(() => {
    setTimeout(() => {
      console.log("Record 3");
      Promise.resolve().then(() => {
        console.log("Record 4");
      });
    });
  });
});

console.log("Record 5");

Promise.resolve().then(() =>
  Promise.resolve().then(() => console.log("Record 6"))
);

/*

1-ый цикл работы event loop:
1. Фазу с таймером пропускаем, т.к. у нас ранее не было никакого кода. Остальные фазы до poll служебные, так что их не трогаем
2. 1-ая строка выполняется сразу
3. 3-ая строка уходит на следующий цикл и выполнится максимально быстро, т.к. не указано время
4. 15-ая строка выполняется сразу
5. 17-ая улетает в микротаски и выполняется в конце цикла, в том числе вложенные promise.resolve()

2-ой цикл работы event loop:
1. На фазе с таймерами нам надо выполнить коллбэк из 3-й строки. Вот здесь не совсем понятно.
Коллбэк выполнится именно на фазе с таймером или просто будет передан в poll с наивысшим приоритетом?
2. 4-ая строка выполняется сразу
3. 5-ая улетает в микротаски и сразу выполняется, т.к. макрозадачи закончились. Здесь планируем скорейшее выполнение 6-ой строки в следующем цикле

3-ий цикл работы event loop:
1. 7-ая строка выполняется сразу
2. 8-ая улетает в микротаски и выполняется сразу, т.к. poll пуст

По итогу получаем: 1, 5, 6, 2, 3, 4

*/
